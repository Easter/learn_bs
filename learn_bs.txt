Beautiful Soup学习笔记：
字符串前加u代表unicode编码；
1：Tag:标签：：
例如：<b class="boldest">Extremely bold</b>
	1:tag.name :: 
		# u'b'
	2:tag.attribute ::即指tag的属性
		本例中有class属性，值为“blodest”
		tag['calss']:
		# u'boldest'
		#也可以直接‘点’取所有属性以字典形式展示
		tag.arrts
		#{u'class':u'boldest'}
		tag的属性可以被添加，删除或修改，tag的属性操作与字典一样
		tag['calss'] = 'verybold'
		tag['id'] = 1
		tag:
		# <b class="vreyblod" id="1">Extremely bold</b>
		del tag['calss']
		del tag['id']
		2.1:多值属性
			2.1.1：
				html4定义了一系列包含多个值的属性，在html5中移除了一些，却增加了更多，最常见的多值属性是classhtml4定义了一系列包含多个值的属性，在html5中移除了一些，却增加了更多，最常见的多值属性是class
				///(一个tag可以有多个CSS的class.)
				css_soup = BeautifulSoup('<p class="body strikeout"></p>')
				css_soup.p['class']
				# ["body","strikeout"] 返回的形式为list相当于字典里的值为list形式储存
					//但是仅适用于多值属性 非多值属性一律以字符串形式返回
				css_soup = BeautifulSoup('<p class="body"></p>')
				css_soup.p['calss']
				# ["body"]
			2.1.2：
				如果一个属性看起来好像有多个值，但在任何版本的HTML中都没有被定义为多值属性，如果一个属性看起来好像有多个值，但在任何版本的HTML中都没有被定义为多值属性，
				///那么Beautiful Soup会将这个属性作为字符串返回
				id_soup = BeautifulSoup('<p id="my id"></p>')
				id_soup.p['id']
				# "my id"
			2.1.3：
				将tag转换成字符串时，多值属性会合并为一个值
				rel_soup = BeautifulSoup('<p>Back to the<a rel="index">homepage</a><p>')
				rel_soup.a[rel]
				# [index]
				rel_soup.a['rel']=['index','contents']
				print rel_soup.p
				# <p>Back to the<a rel='index content'>homepage</a></p>
	
2：可以遍历的字符串：：
##字符串常被包含在tag内。BeautifulSoup用NavigableString 类包装tag中的字符串
	tag.string
	# u'Extremely bold'
	type(tag.string)
	# <class ''bs4.element.NavigableString>
	通过unicode()方法直接将NavigableString对象转换成Unicode字符串：
	unicode_string = unicode(tag.string)
	unicode_string
	# u'Extremely bold'
	type(unicode_string)
	# <type 'unicode'>
	tag中包含的字符串不能被编辑，但是可以被替换成其他的字符串，用replace_with()方法：
	tag.string.replace_with("No longer bold")
	tag.string
	# No longer bold
	# tag中字符串不支持.contends或.string属性或find()
3:BeautifulSoup:
//BeautifulSoup对象表示的是一个文档的全部内容，大部分时候，可以把它当作Tag对象，它支持遍历文档树和搜索文档树中描述的大部分方法
	BeautifulSoup.name
	# u'document'
	注释及特殊字符串
	Tag,NavigableString,BeautifulSoup几乎覆盖了html和lxml的所有内容，但是还有一些特殊对象。容易让人担心的内容是文档的注释部分：
	markup = "<b><!--Hey,buddy.Want to buy a used parser?--></b>"
	soup = BeautifulSoup(markup)
	comment = soup.b.string
	type(comment)
	# <class 'bs4.element.Comment'>
	comment
	# 'Hey,buddy,Want to buy a used parser?'
	但是当他出现在HTML文档中时，Comment对象会使用特殊的格式输出//注释形式的字符串都以Commend类型呈现在HTM中
	print(soup.b.prettify)
	#<b>
		<!--Hey,buddy.Want to buy a used parser?-->
	</b>
	BeautifulSoup定义的其他类型都可能会出现在XML的文档中，BeautifulSoup中文文档可查//都是NavigableString的子类
	
4:遍历文档树：：
爱丽丝梦游仙境文档当作例子
html_doc = """
<html><head><title>The Dormouse's story</title></head>
    <body>
<p class="title"><b>The Dormouse's story</b></p>

<p class="story">Once upon a time there were three little sisters; and their names were
<a href="http://example.com/elsie" class="sister" id="link1">Elsie</a>,
<a href="http://example.com/lacie" class="sister" id="link2">Lacie</a> and
<a href="http://example.com/tillie" class="sister" id="link3">Tillie</a>;
and they lived at the bottom of a well.</p>

<p class="story">...</p>
"""

from bs4 import BeautifulSoup
soup = BeautifulSoup(html_doc, 'html.parser')
	4.1:子节点：
		一个tag可能包含多个字符串或其他的Tag,这些都是这个Tag的子节点（字符串也都是子节点）
		！！！Beautiful Soup中的字符串不支持这些属性，因为字符串没有子节点
	4.2:tag的名字：
		4.2.1操作文档树最简单的方法是告诉它你想获取的tag的name,如果想获取head标签只要用soup.head：
			soup.head
			# <head><title>The Dormouse's story</title></head>
			soup.title
			# <title>The Dormouse's story</title>
		4.2.1下面的代码可以获取<body>标签中的第一个<b>标签：：
			soup.body.b
			# <b>The Dormouse's story</b>
		4.2.3通过点属性的方式获取的只是当前名字的第一个tag
			soup.a
			# <a href="http://example.com/elsie" class="sister" id="link1">Elsie</a>
		4.2.4：如果想要获取所有的a标签，或是通过名字得到比一个tag更多内容时，就需要用到Searching the tree 中描述的放法，例如：fing_all()
			soup.find_all(a)
			[<a href="http://example.com/elsie" class="sister" id="link1">Elsie</a>,
			 <a href="http://example.com/lacie" class="sister" id="link2">Lacie</a>
			 <a href="http://example.com/tillie" class="sister" id="link3">Tillie</a>]
			 #find_all()以list形式返回搜索到的所有标签
		4.2.5：.contends和.children
			1:.contends
				tag的.contends属性可以将tag的子节点以列表的形式输出
				head_tag = soup.head
				head_tag
				# <head><title>The Dormouse's story</title></head>
				
				head_tag.contends:
				# [<title>The Dormouse's story</title>]
				title_tag = head_tag.contends[0]#列表的第一个元素
				title_tag
				# <title>The Dormouse's story</title>
				title_tag.contends
				# [The Dormouse's story]
				BeautifulSoup对象本身一定会包含子节点，也就是说<html>标签也是<BeautifulSoup>对象的子节点
				len(soup.contends)
				# 1
				soup.contends[0].name
				# html
				字符串没有.contends属性，因为字符串没有子节点
				例如：text = title.contends[0]
					  text.contends
					  # AttributeError: "NavigableString" object has no attribute 'contents'
			2:.children
				通过tag的.children生成器，可以对tag的子节点进行循环：
				,,,,,,
			 
		
			
			
			
			
			
			